"""
CI/CD Pipeline Integration System

Provides integrations with popular CI/CD platforms including GitHub Actions,
Jenkins, and GitLab CI for automated code reviews, quality gates, and deployment assistance.
"""

import asyncio
import json
import logging
import yaml
from abc import ABC, abstractmethod
from dataclasses import dataclass, asdict
from typing import Dict, List, Optional, Any, Callable
from pathlib import Path
import aiohttp
from datetime import datetime

from ..core.code_intelligence import CodeIntelligence
from ..core.tool_executor import ToolExecutor
from ..agents.security import SecurityAgent
from ..agents.testing import TesterAgent
from ..agents.performance import PerformanceAgent


@dataclass
class PullRequest:
    """Pull request information"""
    id: str
    title: str
    description: str
    author: str
    source_branch: str
    target_branch: str
    files_changed: List[str]
    additions: int
    deletions: int
    url: str
    created_at: datetime


@dataclass
class ReviewResult:
    """Code review result"""
    overall_score: float
    security_issues: List[Dict[str, Any]]
    performance_issues: List[Dict[str, Any]]
    code_quality_issues: List[Dict[str, Any]]
    test_coverage: float
    recommendations: List[str]
    approval_status: str  # approved, needs_changes, rejected
    detailed_feedback: str


@dataclass
class DeploymentPlan:
    """Deployment plan generated by AI"""
    environment: str
    steps: List[Dict[str, Any]]
    rollback_plan: List[Dict[str, Any]]
    health_checks: List[Dict[str, Any]]
    estimated_duration: int
    risk_assessment: Dict[str, Any]


@dataclass
class QualityGate:
    """Quality gate configuration"""
    name: str
    conditions: List[Dict[str, Any]]
    threshold: float
    blocking: bool
    description: str


class CICDIntegrationBase(ABC):
    """Base class for CI/CD integrations"""
    
    def __init__(self, code_intelligence: CodeIntelligence, security_agent: SecurityAgent,
                 tester_agent: TesterAgent, performance_agent: PerformanceAgent,
                 tool_executor: Optional[ToolExecutor] = None):
        self.code_intelligence = code_intelligence
        self.security_agent = security_agent
        self.tester_agent = tester_agent
        self.performance_agent = performance_agent
        self.tool_executor = tool_executor or ToolExecutor()
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @abstractmethod
    async def review_pull_request(self, pr: PullRequest) -> ReviewResult:
        """Review a pull request automatically"""
        pass
    
    @abstractmethod
    async def generate_deployment_plan(self, changes: List[Dict[str, Any]]) -> DeploymentPlan:
        """Generate deployment plan for changes"""
        pass
    
    @abstractmethod
    async def setup_quality_gates(self, project_config: Dict[str, Any]) -> List[QualityGate]:
        """Setup quality gates for the project"""
        pass
    
    @abstractmethod
    async def monitor_deployment(self, deployment_id: str) -> Dict[str, Any]:
        """Monitor deployment progress and health"""
        pass


class GitHubActionsIntegration(CICDIntegrationBase):
    """GitHub Actions integration for automated reviews and workflows"""
    
    def __init__(self, code_intelligence: CodeIntelligence, security_agent: SecurityAgent,
                 tester_agent: TesterAgent, performance_agent: PerformanceAgent,
                 github_token: str, tool_executor: Optional[ToolExecutor] = None):
        super().__init__(code_intelligence, security_agent, tester_agent, performance_agent, tool_executor)
        self.github_token = github_token
        self.api_base_url = "https://api.github.com"
        self.session = None
    
    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create HTTP session with GitHub API headers"""
        if not self.session:
            headers = {
                "Authorization": f"token {self.github_token}",
                "Accept": "application/vnd.github.v3+json",
                "User-Agent": "CodeGenie-Bot/1.0"
            }
            self.session = aiohttp.ClientSession(headers=headers)
        return self.session
    
    async def review_pull_request(self, pr: PullRequest) -> ReviewResult:
        """Automatically review GitHub pull request"""
        try:
            # Get PR files and changes
            session = await self._get_session()
            pr_files = await self._get_pr_files(session, pr)
            
            # Perform comprehensive analysis
            security_issues = []
            performance_issues = []
            code_quality_issues = []
            
            for file_info in pr_files:
                if file_info["status"] in ["added", "modified"]:
                    file_content = await self._get_file_content(session, file_info)
                    
                    # Security analysis
                    security_result = await self.security_agent.scan_for_vulnerabilities(file_content)
                    if security_result.vulnerabilities:
                        security_issues.extend([
                            {
                                "file": file_info["filename"],
                                "line": vuln.line_number,
                                "severity": vuln.severity,
                                "description": vuln.description,
                                "recommendation": vuln.fix_suggestion
                            }
                            for vuln in security_result.vulnerabilities
                        ])
                    
                    # Performance analysis
                    perf_result = await self.performance_agent.analyze_performance(file_content)
                    if perf_result.bottlenecks:
                        performance_issues.extend([
                            {
                                "file": file_info["filename"],
                                "line": bottleneck.line_number,
                                "type": bottleneck.type,
                                "description": bottleneck.description,
                                "optimization": bottleneck.optimization_suggestion
                            }
                            for bottleneck in perf_result.bottlenecks
                        ])
                    
                    # Code quality analysis
                    quality_result = await self.code_intelligence.analyze_code_quality(file_content)
                    if quality_result.issues:
                        code_quality_issues.extend([
                            {
                                "file": file_info["filename"],
                                "line": issue.line_number,
                                "type": issue.type,
                                "description": issue.description,
                                "suggestion": issue.fix_suggestion
                            }
                            for issue in quality_result.issues
                        ])
            
            # Calculate test coverage
            test_coverage = await self._calculate_test_coverage(session, pr)
            
            # Generate overall score and recommendations
            overall_score = self._calculate_overall_score(
                security_issues, performance_issues, code_quality_issues, test_coverage
            )
            
            recommendations = self._generate_recommendations(
                security_issues, performance_issues, code_quality_issues, test_coverage
            )
            
            # Determine approval status
            approval_status = self._determine_approval_status(overall_score, security_issues)
            
            # Generate detailed feedback
            detailed_feedback = self._generate_detailed_feedback(
                security_issues, performance_issues, code_quality_issues, recommendations
            )
            
            # Post review to GitHub
            await self._post_review_to_github(session, pr, {
                "security_issues": security_issues,
                "performance_issues": performance_issues,
                "code_quality_issues": code_quality_issues,
                "recommendations": recommendations,
                "approval_status": approval_status,
                "detailed_feedback": detailed_feedback
            })
            
            return ReviewResult(
                overall_score=overall_score,
                security_issues=security_issues,
                performance_issues=performance_issues,
                code_quality_issues=code_quality_issues,
                test_coverage=test_coverage,
                recommendations=recommendations,
                approval_status=approval_status,
                detailed_feedback=detailed_feedback
            )
            
        except Exception as e:
            self.logger.error(f"Error reviewing pull request: {e}")
            raise
    
    async def generate_deployment_plan(self, changes: List[Dict[str, Any]]) -> DeploymentPlan:
        """Generate deployment plan for GitHub Actions"""
        try:
            # Analyze changes to determine deployment strategy
            deployment_strategy = await self._analyze_deployment_strategy(changes)
            
            # Generate deployment steps
            steps = []
            
            # Pre-deployment checks
            steps.append({
                "name": "Pre-deployment Security Scan",
                "action": "security-scan",
                "timeout": "5m",
                "required": True
            })
            
            steps.append({
                "name": "Run Test Suite",
                "action": "test",
                "command": "npm test",
                "timeout": "10m",
                "required": True
            })
            
            # Deployment steps based on strategy
            if deployment_strategy == "blue-green":
                steps.extend([
                    {
                        "name": "Deploy to Green Environment",
                        "action": "deploy",
                        "environment": "green",
                        "timeout": "15m"
                    },
                    {
                        "name": "Health Check Green Environment",
                        "action": "health-check",
                        "environment": "green",
                        "timeout": "5m"
                    },
                    {
                        "name": "Switch Traffic to Green",
                        "action": "traffic-switch",
                        "from": "blue",
                        "to": "green",
                        "timeout": "2m"
                    }
                ])
            else:  # rolling deployment
                steps.extend([
                    {
                        "name": "Rolling Deployment",
                        "action": "rolling-deploy",
                        "batch_size": "25%",
                        "timeout": "20m"
                    }
                ])
            
            # Generate rollback plan
            rollback_plan = [
                {
                    "name": "Stop Deployment",
                    "action": "stop-deployment",
                    "timeout": "1m"
                },
                {
                    "name": "Rollback to Previous Version",
                    "action": "rollback",
                    "timeout": "10m"
                },
                {
                    "name": "Verify Rollback",
                    "action": "health-check",
                    "timeout": "5m"
                }
            ]
            
            # Generate health checks
            health_checks = [
                {
                    "name": "API Health Check",
                    "endpoint": "/health",
                    "expected_status": 200,
                    "timeout": "30s"
                },
                {
                    "name": "Database Connectivity",
                    "type": "database",
                    "timeout": "10s"
                }
            ]
            
            # Risk assessment
            risk_assessment = await self._assess_deployment_risk(changes)
            
            return DeploymentPlan(
                environment="production",
                steps=steps,
                rollback_plan=rollback_plan,
                health_checks=health_checks,
                estimated_duration=30,  # minutes
                risk_assessment=risk_assessment
            )
            
        except Exception as e:
            self.logger.error(f"Error generating deployment plan: {e}")
            raise
    
    async def setup_quality_gates(self, project_config: Dict[str, Any]) -> List[QualityGate]:
        """Setup quality gates for GitHub Actions"""
        try:
            quality_gates = []
            
            # Security quality gate
            quality_gates.append(QualityGate(
                name="Security Gate",
                conditions=[
                    {"metric": "security_vulnerabilities", "operator": "<=", "value": 0, "severity": "high"},
                    {"metric": "security_vulnerabilities", "operator": "<=", "value": 2, "severity": "medium"}
                ],
                threshold=0.8,
                blocking=True,
                description="Ensures no high-severity security vulnerabilities"
            ))
            
            # Code Quality Gate
            quality_gates.append(QualityGate(
                name="Code Quality Gate",
                conditions=[
                    {"metric": "code_coverage", "operator": ">=", "value": 80},
                    {"metric": "code_smells", "operator": "<=", "value": 10},
                    {"metric": "duplicated_lines", "operator": "<=", "value": 3}
                ],
                threshold=0.7,
                blocking=False,
                description="Maintains code quality standards"
            ))
            
            # Performance Gate
            quality_gates.append(QualityGate(
                name="Performance Gate",
                conditions=[
                    {"metric": "performance_score", "operator": ">=", "value": 0.8},
                    {"metric": "memory_leaks", "operator": "<=", "value": 0}
                ],
                threshold=0.8,
                blocking=True,
                description="Ensures performance standards are met"
            ))
            
            # Generate GitHub Actions workflow
            await self._generate_quality_gate_workflow(quality_gates, project_config)
            
            return quality_gates
            
        except Exception as e:
            self.logger.error(f"Error setting up quality gates: {e}")
            raise
    
    async def monitor_deployment(self, deployment_id: str) -> Dict[str, Any]:
        """Monitor GitHub Actions deployment"""
        try:
            session = await self._get_session()
            
            # Get deployment status from GitHub API
            deployment_url = f"{self.api_base_url}/repos/{deployment_id}/deployments"
            async with session.get(deployment_url) as response:
                deployments = await response.json()
            
            if not deployments:
                return {"status": "not_found", "message": "Deployment not found"}
            
            latest_deployment = deployments[0]
            
            # Get deployment statuses
            statuses_url = latest_deployment["statuses_url"]
            async with session.get(statuses_url) as response:
                statuses = await response.json()
            
            # Analyze deployment health
            health_status = await self._check_deployment_health(latest_deployment)
            
            return {
                "deployment_id": deployment_id,
                "status": latest_deployment["state"],
                "environment": latest_deployment["environment"],
                "created_at": latest_deployment["created_at"],
                "updated_at": latest_deployment["updated_at"],
                "statuses": statuses,
                "health": health_status,
                "url": latest_deployment["url"]
            }
            
        except Exception as e:
            self.logger.error(f"Error monitoring deployment: {e}")
            return {"status": "error", "message": str(e)}
    
    async def _get_pr_files(self, session: aiohttp.ClientSession, pr: PullRequest) -> List[Dict[str, Any]]:
        """Get files changed in pull request"""
        # Implementation to get PR files from GitHub API
        return []
    
    async def _get_file_content(self, session: aiohttp.ClientSession, file_info: Dict[str, Any]) -> str:
        """Get content of a file from GitHub"""
        # Implementation to get file content
        return ""
    
    async def _calculate_test_coverage(self, session: aiohttp.ClientSession, pr: PullRequest) -> float:
        """Calculate test coverage for PR"""
        # Implementation to calculate test coverage
        return 0.85
    
    def _calculate_overall_score(self, security_issues: List, performance_issues: List,
                               code_quality_issues: List, test_coverage: float) -> float:
        """Calculate overall PR score"""
        base_score = 1.0
        
        # Deduct for issues
        base_score -= len(security_issues) * 0.1
        base_score -= len(performance_issues) * 0.05
        base_score -= len(code_quality_issues) * 0.02
        
        # Factor in test coverage
        base_score *= test_coverage
        
        return max(0.0, min(1.0, base_score))
    
    def _generate_recommendations(self, security_issues: List, performance_issues: List,
                                code_quality_issues: List, test_coverage: float) -> List[str]:
        """Generate recommendations based on analysis"""
        recommendations = []
        
        if security_issues:
            recommendations.append("Address security vulnerabilities before merging")
        
        if performance_issues:
            recommendations.append("Consider performance optimizations")
        
        if test_coverage < 0.8:
            recommendations.append("Increase test coverage to at least 80%")
        
        if code_quality_issues:
            recommendations.append("Fix code quality issues for better maintainability")
        
        return recommendations
    
    def _determine_approval_status(self, overall_score: float, security_issues: List) -> str:
        """Determine approval status based on analysis"""
        if security_issues:
            return "rejected"
        elif overall_score >= 0.8:
            return "approved"
        else:
            return "needs_changes"
    
    def _generate_detailed_feedback(self, security_issues: List, performance_issues: List,
                                  code_quality_issues: List, recommendations: List) -> str:
        """Generate detailed feedback for the PR"""
        feedback = "## CodeGenie Automated Review\n\n"
        
        if security_issues:
            feedback += "### ðŸ”’ Security Issues\n"
            for issue in security_issues[:5]:  # Limit to top 5
                feedback += f"- **{issue['file']}:{issue['line']}** - {issue['description']}\n"
            feedback += "\n"
        
        if performance_issues:
            feedback += "### âš¡ Performance Issues\n"
            for issue in performance_issues[:5]:
                feedback += f"- **{issue['file']}:{issue['line']}** - {issue['description']}\n"
            feedback += "\n"
        
        if code_quality_issues:
            feedback += "### ðŸ§¹ Code Quality Issues\n"
            for issue in code_quality_issues[:5]:
                feedback += f"- **{issue['file']}:{issue['line']}** - {issue['description']}\n"
            feedback += "\n"
        
        if recommendations:
            feedback += "### ðŸ’¡ Recommendations\n"
            for rec in recommendations:
                feedback += f"- {rec}\n"
        
        return feedback
    
    async def _post_review_to_github(self, session: aiohttp.ClientSession, pr: PullRequest,
                                   review_data: Dict[str, Any]):
        """Post review comments to GitHub PR"""
        # Implementation to post review to GitHub
        pass
    
    async def _analyze_deployment_strategy(self, changes: List[Dict[str, Any]]) -> str:
        """Analyze changes to determine best deployment strategy"""
        # Simple heuristic - use blue-green for database changes, rolling otherwise
        for change in changes:
            if "migration" in change.get("type", "") or "schema" in change.get("files", []):
                return "blue-green"
        return "rolling"
    
    async def _assess_deployment_risk(self, changes: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess risk level of deployment"""
        risk_factors = []
        risk_score = 0.0
        
        for change in changes:
            if change.get("type") == "database_migration":
                risk_factors.append("Database schema changes")
                risk_score += 0.3
            elif change.get("type") == "api_breaking":
                risk_factors.append("Breaking API changes")
                risk_score += 0.4
            elif change.get("size", 0) > 1000:  # lines changed
                risk_factors.append("Large code changes")
                risk_score += 0.2
        
        risk_level = "low"
        if risk_score > 0.7:
            risk_level = "high"
        elif risk_score > 0.4:
            risk_level = "medium"
        
        return {
            "level": risk_level,
            "score": min(1.0, risk_score),
            "factors": risk_factors,
            "mitigation_strategies": self._get_mitigation_strategies(risk_factors)
        }
    
    def _get_mitigation_strategies(self, risk_factors: List[str]) -> List[str]:
        """Get mitigation strategies for identified risks"""
        strategies = []
        
        if "Database schema changes" in risk_factors:
            strategies.append("Use database migration rollback scripts")
            strategies.append("Test migrations on staging environment first")
        
        if "Breaking API changes" in risk_factors:
            strategies.append("Implement API versioning")
            strategies.append("Coordinate with API consumers")
        
        if "Large code changes" in risk_factors:
            strategies.append("Deploy in smaller batches")
            strategies.append("Increase monitoring during deployment")
        
        return strategies
    
    async def _generate_quality_gate_workflow(self, quality_gates: List[QualityGate],
                                            project_config: Dict[str, Any]):
        """Generate GitHub Actions workflow for quality gates"""
        workflow = {
            "name": "CodeGenie Quality Gates",
            "on": {
                "pull_request": {
                    "branches": ["main", "develop"]
                }
            },
            "jobs": {
                "quality-gates": {
                    "runs-on": "ubuntu-latest",
                    "steps": [
                        {
                            "uses": "actions/checkout@v3"
                        },
                        {
                            "name": "Setup Node.js",
                            "uses": "actions/setup-node@v3",
                            "with": {
                                "node-version": "18"
                            }
                        }
                    ]
                }
            }
        }
        
        # Add steps for each quality gate
        for gate in quality_gates:
            workflow["jobs"]["quality-gates"]["steps"].append({
                "name": f"Run {gate.name}",
                "run": f"echo 'Running {gate.name}'",
                "continue-on-error": not gate.blocking
            })
        
        # Save workflow file
        workflow_path = Path(".github/workflows/codegenie-quality-gates.yml")
        workflow_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(workflow_path, 'w') as f:
            yaml.dump(workflow, f, default_flow_style=False)
    
    async def _check_deployment_health(self, deployment: Dict[str, Any]) -> Dict[str, Any]:
        """Check health of deployment"""
        # Implementation to check deployment health
        return {
            "status": "healthy",
            "checks": [
                {"name": "API Health", "status": "passing"},
                {"name": "Database", "status": "passing"}
            ]
        }


class JenkinsIntegration(CICDIntegrationBase):
    """Jenkins integration for continuous code analysis"""
    
    def __init__(self, code_intelligence: CodeIntelligence, security_agent: SecurityAgent,
                 tester_agent: TesterAgent, performance_agent: PerformanceAgent,
                 jenkins_url: str, jenkins_user: str, jenkins_token: str,
                 tool_executor: Optional[ToolExecutor] = None):
        super().__init__(code_intelligence, security_agent, tester_agent, performance_agent, tool_executor)
        self.jenkins_url = jenkins_url
        self.jenkins_user = jenkins_user
        self.jenkins_token = jenkins_token
        self.session = None
    
    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create HTTP session with Jenkins authentication"""
        if not self.session:
            auth = aiohttp.BasicAuth(self.jenkins_user, self.jenkins_token)
            self.session = aiohttp.ClientSession(auth=auth)
        return self.session
    
    async def review_pull_request(self, pr: PullRequest) -> ReviewResult:
        """Review pull request using Jenkins pipeline"""
        try:
            # Trigger Jenkins job for PR analysis
            job_name = "codegenie-pr-analysis"
            build_params = {
                "PR_ID": pr.id,
                "SOURCE_BRANCH": pr.source_branch,
                "TARGET_BRANCH": pr.target_branch
            }
            
            build_number = await self._trigger_jenkins_job(job_name, build_params)
            
            # Wait for job completion
            job_result = await self._wait_for_job_completion(job_name, build_number)
            
            # Parse results from Jenkins artifacts
            review_result = await self._parse_jenkins_results(job_name, build_number)
            
            return review_result
            
        except Exception as e:
            self.logger.error(f"Error reviewing PR with Jenkins: {e}")
            raise
    
    async def generate_deployment_plan(self, changes: List[Dict[str, Any]]) -> DeploymentPlan:
        """Generate deployment plan using Jenkins pipeline"""
        try:
            # Create Jenkins pipeline for deployment
            pipeline_script = self._generate_jenkins_pipeline(changes)
            
            # Save pipeline and trigger job
            job_name = "codegenie-deployment-plan"
            await self._create_or_update_pipeline_job(job_name, pipeline_script)
            
            # Generate deployment plan based on changes
            deployment_plan = DeploymentPlan(
                environment="production",
                steps=[
                    {"name": "Build", "stage": "build", "timeout": "10m"},
                    {"name": "Test", "stage": "test", "timeout": "15m"},
                    {"name": "Deploy", "stage": "deploy", "timeout": "20m"}
                ],
                rollback_plan=[
                    {"name": "Rollback", "stage": "rollback", "timeout": "10m"}
                ],
                health_checks=[
                    {"name": "Health Check", "endpoint": "/health", "timeout": "5m"}
                ],
                estimated_duration=45,
                risk_assessment={"level": "medium", "score": 0.5}
            )
            
            return deployment_plan
            
        except Exception as e:
            self.logger.error(f"Error generating Jenkins deployment plan: {e}")
            raise
    
    async def setup_quality_gates(self, project_config: Dict[str, Any]) -> List[QualityGate]:
        """Setup quality gates in Jenkins"""
        try:
            # Create Jenkins jobs for quality gates
            quality_gates = [
                QualityGate(
                    name="Security Gate",
                    conditions=[{"metric": "security_score", "operator": ">=", "value": 0.8}],
                    threshold=0.8,
                    blocking=True,
                    description="Security quality gate"
                ),
                QualityGate(
                    name="Performance Gate", 
                    conditions=[{"metric": "performance_score", "operator": ">=", "value": 0.7}],
                    threshold=0.7,
                    blocking=False,
                    description="Performance quality gate"
                )
            ]
            
            # Create Jenkins pipeline for quality gates
            for gate in quality_gates:
                job_name = f"codegenie-{gate.name.lower().replace(' ', '-')}"
                pipeline_script = self._generate_quality_gate_pipeline(gate)
                await self._create_or_update_pipeline_job(job_name, pipeline_script)
            
            return quality_gates
            
        except Exception as e:
            self.logger.error(f"Error setting up Jenkins quality gates: {e}")
            raise
    
    async def monitor_deployment(self, deployment_id: str) -> Dict[str, Any]:
        """Monitor Jenkins deployment"""
        try:
            # Get deployment job status
            job_name, build_number = deployment_id.split("/")
            
            session = await self._get_session()
            build_url = f"{self.jenkins_url}/job/{job_name}/{build_number}/api/json"
            
            async with session.get(build_url) as response:
                build_info = await response.json()
            
            return {
                "deployment_id": deployment_id,
                "status": "success" if build_info["result"] == "SUCCESS" else "failed",
                "duration": build_info["duration"],
                "url": build_info["url"],
                "console_output": await self._get_console_output(job_name, build_number)
            }
            
        except Exception as e:
            self.logger.error(f"Error monitoring Jenkins deployment: {e}")
            return {"status": "error", "message": str(e)}
    
    async def _trigger_jenkins_job(self, job_name: str, params: Dict[str, Any]) -> int:
        """Trigger Jenkins job with parameters"""
        session = await self._get_session()
        
        # Build parameters string
        param_string = "&".join([f"{k}={v}" for k, v in params.items()])
        trigger_url = f"{self.jenkins_url}/job/{job_name}/buildWithParameters?{param_string}"
        
        async with session.post(trigger_url) as response:
            if response.status == 201:
                # Get build number from queue
                queue_url = response.headers.get("Location")
                return await self._get_build_number_from_queue(queue_url)
            else:
                raise Exception(f"Failed to trigger Jenkins job: {response.status}")
    
    async def _wait_for_job_completion(self, job_name: str, build_number: int) -> Dict[str, Any]:
        """Wait for Jenkins job to complete"""
        session = await self._get_session()
        build_url = f"{self.jenkins_url}/job/{job_name}/{build_number}/api/json"
        
        while True:
            async with session.get(build_url) as response:
                build_info = await response.json()
                
                if not build_info["building"]:
                    return build_info
                
                await asyncio.sleep(10)  # Wait 10 seconds before checking again
    
    async def _parse_jenkins_results(self, job_name: str, build_number: int) -> ReviewResult:
        """Parse Jenkins job results into ReviewResult"""
        # Implementation to parse Jenkins artifacts and logs
        return ReviewResult(
            overall_score=0.8,
            security_issues=[],
            performance_issues=[],
            code_quality_issues=[],
            test_coverage=0.85,
            recommendations=["Jenkins analysis completed"],
            approval_status="approved",
            detailed_feedback="Jenkins pipeline completed successfully"
        )
    
    def _generate_jenkins_pipeline(self, changes: List[Dict[str, Any]]) -> str:
        """Generate Jenkins pipeline script"""
        pipeline = """
        pipeline {
            agent any
            
            stages {
                stage('Checkout') {
                    steps {
                        checkout scm
                    }
                }
                
                stage('Build') {
                    steps {
                        sh 'npm install'
                        sh 'npm run build'
                    }
                }
                
                stage('Test') {
                    steps {
                        sh 'npm test'
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        sh 'npm audit'
                    }
                }
                
                stage('Deploy') {
                    steps {
                        sh 'npm run deploy'
                    }
                }
            }
            
            post {
                always {
                    archiveArtifacts artifacts: 'reports/**/*', fingerprint: true
                    publishTestResults testResultsPattern: 'test-results.xml'
                }
            }
        }
        """
        return pipeline
    
    def _generate_quality_gate_pipeline(self, gate: QualityGate) -> str:
        """Generate Jenkins pipeline for quality gate"""
        pipeline = f"""
        pipeline {{
            agent any
            
            stages {{
                stage('{gate.name}') {{
                    steps {{
                        script {{
                            // Quality gate implementation
                            echo 'Running {gate.name}'
                            
                            // Check conditions
                            def passed = true
                            // Implementation for gate conditions
                            
                            if (!passed && {str(gate.blocking).lower()}) {{
                                error('{gate.name} failed - blocking deployment')
                            }}
                        }}
                    }}
                }}
            }}
        }}
        """
        return pipeline
    
    async def _create_or_update_pipeline_job(self, job_name: str, pipeline_script: str):
        """Create or update Jenkins pipeline job"""
        # Implementation to create/update Jenkins job via API
        pass
    
    async def _get_build_number_from_queue(self, queue_url: str) -> int:
        """Get build number from Jenkins queue"""
        # Implementation to get build number from queue
        return 1
    
    async def _get_console_output(self, job_name: str, build_number: int) -> str:
        """Get console output from Jenkins build"""
        session = await self._get_session()
        console_url = f"{self.jenkins_url}/job/{job_name}/{build_number}/consoleText"
        
        async with session.get(console_url) as response:
            return await response.text()


class GitLabCIIntegration(CICDIntegrationBase):
    """GitLab CI integration for quality gates and deployment"""
    
    def __init__(self, code_intelligence: CodeIntelligence, security_agent: SecurityAgent,
                 tester_agent: TesterAgent, performance_agent: PerformanceAgent,
                 gitlab_url: str, gitlab_token: str, tool_executor: Optional[ToolExecutor] = None):
        super().__init__(code_intelligence, security_agent, tester_agent, performance_agent, tool_executor)
        self.gitlab_url = gitlab_url
        self.gitlab_token = gitlab_token
        self.session = None
    
    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create HTTP session with GitLab authentication"""
        if not self.session:
            headers = {
                "Authorization": f"Bearer {self.gitlab_token}",
                "Content-Type": "application/json"
            }
            self.session = aiohttp.ClientSession(headers=headers)
        return self.session
    
    async def review_pull_request(self, pr: PullRequest) -> ReviewResult:
        """Review merge request in GitLab"""
        try:
            # Get MR details from GitLab API
            session = await self._get_session()
            mr_url = f"{self.gitlab_url}/api/v4/projects/{pr.id}/merge_requests"
            
            # Perform analysis similar to GitHub but adapted for GitLab
            # Implementation details...
            
            return ReviewResult(
                overall_score=0.8,
                security_issues=[],
                performance_issues=[],
                code_quality_issues=[],
                test_coverage=0.85,
                recommendations=["GitLab MR analysis completed"],
                approval_status="approved",
                detailed_feedback="GitLab CI analysis completed successfully"
            )
            
        except Exception as e:
            self.logger.error(f"Error reviewing GitLab MR: {e}")
            raise
    
    async def generate_deployment_plan(self, changes: List[Dict[str, Any]]) -> DeploymentPlan:
        """Generate deployment plan for GitLab CI"""
        try:
            # Generate GitLab CI YAML configuration
            gitlab_ci_config = self._generate_gitlab_ci_config(changes)
            
            # Save .gitlab-ci.yml file
            with open(".gitlab-ci.yml", "w") as f:
                yaml.dump(gitlab_ci_config, f, default_flow_style=False)
            
            return DeploymentPlan(
                environment="production",
                steps=[
                    {"name": "build", "stage": "build"},
                    {"name": "test", "stage": "test"},
                    {"name": "deploy", "stage": "deploy"}
                ],
                rollback_plan=[
                    {"name": "rollback", "stage": "rollback"}
                ],
                health_checks=[
                    {"name": "health_check", "stage": "verify"}
                ],
                estimated_duration=30,
                risk_assessment={"level": "medium", "score": 0.5}
            )
            
        except Exception as e:
            self.logger.error(f"Error generating GitLab deployment plan: {e}")
            raise
    
    async def setup_quality_gates(self, project_config: Dict[str, Any]) -> List[QualityGate]:
        """Setup quality gates in GitLab CI"""
        try:
            quality_gates = [
                QualityGate(
                    name="Security Gate",
                    conditions=[{"metric": "security_score", "operator": ">=", "value": 0.8}],
                    threshold=0.8,
                    blocking=True,
                    description="Security quality gate for GitLab"
                )
            ]
            
            # Update .gitlab-ci.yml with quality gates
            gitlab_ci_config = self._generate_quality_gates_config(quality_gates)
            
            return quality_gates
            
        except Exception as e:
            self.logger.error(f"Error setting up GitLab quality gates: {e}")
            raise
    
    async def monitor_deployment(self, deployment_id: str) -> Dict[str, Any]:
        """Monitor GitLab deployment"""
        try:
            session = await self._get_session()
            deployment_url = f"{self.gitlab_url}/api/v4/projects/{deployment_id}/deployments"
            
            async with session.get(deployment_url) as response:
                deployments = await response.json()
            
            if deployments:
                latest_deployment = deployments[0]
                return {
                    "deployment_id": deployment_id,
                    "status": latest_deployment["status"],
                    "environment": latest_deployment["environment"]["name"],
                    "created_at": latest_deployment["created_at"],
                    "updated_at": latest_deployment["updated_at"]
                }
            
            return {"status": "not_found"}
            
        except Exception as e:
            self.logger.error(f"Error monitoring GitLab deployment: {e}")
            return {"status": "error", "message": str(e)}
    
    def _generate_gitlab_ci_config(self, changes: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate GitLab CI configuration"""
        config = {
            "stages": ["build", "test", "security", "deploy", "verify"],
            "variables": {
                "CODEGENIE_ENABLED": "true"
            },
            "build": {
                "stage": "build",
                "script": [
                    "npm install",
                    "npm run build"
                ],
                "artifacts": {
                    "paths": ["dist/"]
                }
            },
            "test": {
                "stage": "test",
                "script": [
                    "npm test",
                    "npm run coverage"
                ],
                "coverage": "/Coverage: \\d+\\.\\d+%/",
                "artifacts": {
                    "reports": {
                        "coverage_report": {
                            "coverage_format": "cobertura",
                            "path": "coverage/cobertura-coverage.xml"
                        }
                    }
                }
            },
            "security_scan": {
                "stage": "security",
                "script": [
                    "npm audit",
                    "echo 'Running CodeGenie security analysis'"
                ],
                "allow_failure": False
            },
            "deploy": {
                "stage": "deploy",
                "script": [
                    "echo 'Deploying application'",
                    "npm run deploy"
                ],
                "environment": {
                    "name": "production",
                    "url": "https://example.com"
                },
                "only": ["main"]
            }
        }
        
        return config
    
    def _generate_quality_gates_config(self, quality_gates: List[QualityGate]) -> Dict[str, Any]:
        """Generate GitLab CI config for quality gates"""
        config = {}
        
        for gate in quality_gates:
            job_name = gate.name.lower().replace(" ", "_")
            config[job_name] = {
                "stage": "test",
                "script": [
                    f"echo 'Running {gate.name}'",
                    "# Quality gate implementation"
                ],
                "allow_failure": not gate.blocking
            }
        
        return config


class CICDIntegrationManager:
    """Manager for all CI/CD integrations"""
    
    def __init__(self, code_intelligence: CodeIntelligence, security_agent: SecurityAgent,
                 tester_agent: TesterAgent, performance_agent: PerformanceAgent,
                 tool_executor: Optional[ToolExecutor] = None):
        self.code_intelligence = code_intelligence
        self.security_agent = security_agent
        self.tester_agent = tester_agent
        self.performance_agent = performance_agent
        self.tool_executor = tool_executor or ToolExecutor()
        self.logger = logging.getLogger(self.__class__.__name__)
        
        self.integrations: Dict[str, CICDIntegrationBase] = {}
    
    def add_github_integration(self, github_token: str):
        """Add GitHub Actions integration"""
        self.integrations["github"] = GitHubActionsIntegration(
            self.code_intelligence, self.security_agent,
            self.tester_agent, self.performance_agent, github_token, self.tool_executor
        )
    
    def add_jenkins_integration(self, jenkins_url: str, jenkins_user: str, jenkins_token: str):
        """Add Jenkins integration"""
        self.integrations["jenkins"] = JenkinsIntegration(
            self.code_intelligence, self.security_agent,
            self.tester_agent, self.performance_agent,
            jenkins_url, jenkins_user, jenkins_token, self.tool_executor
        )
    
    def add_gitlab_integration(self, gitlab_url: str, gitlab_token: str):
        """Add GitLab CI integration"""
        self.integrations["gitlab"] = GitLabCIIntegration(
            self.code_intelligence, self.security_agent,
            self.tester_agent, self.performance_agent,
            gitlab_url, gitlab_token, self.tool_executor
        )
    
    async def review_pull_request(self, platform: str, pr: PullRequest) -> ReviewResult:
        """Review pull request on specified platform"""
        if platform not in self.integrations:
            raise ValueError(f"Platform not configured: {platform}")
        
        return await self.integrations[platform].review_pull_request(pr)
    
    async def generate_deployment_plan(self, platform: str, changes: List[Dict[str, Any]]) -> DeploymentPlan:
        """Generate deployment plan for specified platform"""
        if platform not in self.integrations:
            raise ValueError(f"Platform not configured: {platform}")
        
        return await self.integrations[platform].generate_deployment_plan(changes)
    
    async def setup_quality_gates(self, platform: str, project_config: Dict[str, Any]) -> List[QualityGate]:
        """Setup quality gates for specified platform"""
        if platform not in self.integrations:
            raise ValueError(f"Platform not configured: {platform}")
        
        return await self.integrations[platform].setup_quality_gates(project_config)
    
    async def monitor_deployment(self, platform: str, deployment_id: str) -> Dict[str, Any]:
        """Monitor deployment on specified platform"""
        if platform not in self.integrations:
            raise ValueError(f"Platform not configured: {platform}")
        
        return await self.integrations[platform].monitor_deployment(deployment_id)
    
    def get_supported_platforms(self) -> List[str]:
        """Get list of supported CI/CD platforms"""
        return list(self.integrations.keys())
    
    async def cleanup(self):
        """Cleanup all integrations"""
        for integration in self.integrations.values():
            if hasattr(integration, 'session') and integration.session:
                await integration.session.close()
        
        self.integrations.clear()
        self.logger.info("All CI/CD integrations cleaned up")